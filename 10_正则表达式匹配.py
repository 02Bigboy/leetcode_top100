# 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
# '.' 匹配任意单个字符
# '*' 匹配零个或多个前面的那一个元素
# 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串.
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        """
        思路：动态规划， 定义二维dp数组，其中dp[i][j]表示s的前i个字符和p的前j个字符是否匹配，
        为了方便初始化，我们将s和p的长度均+1
        考虑到P中可能出现三种字符：普通字母(a-z)、'*'或者是'.', 则其动态转移方程分别是：
        1) 如果p[j]为普通字母，dp[i][j]==dp[i-1][j-1] and s[i]==p[j]
        2) 如果p[j]为'.', dp[i][j]==dp[i-1][j-1]
        3) 如果p[j]为'*', 则情况比较复杂, 分以下两种情况讨论：
           A. 以s="c", p="ca*"为例，此时'*'匹配0次，dp[i][j]==dp[i][j-2]
           B. 以s="caa", p="ca*"为例，此时'*'匹配多次，dp[i][j]==dp[i-1][j] and s[i]==p[j-1] (考虑到通配符'.', 还有p[j-1]=='.'的情况)
        """
        # 为了解决s="a", p="c*a"中*组合在p开头0次匹配的问题，我们需要额外初始化dp[0][:], 为此，在s前加一特殊字符，以方便操作
        s = " " + s
        dp = [[False]*(len(p)+1) for _ in range(len(s))]   # [len(s)+1, len(p)+1]
        dp[0][0] = True  # 假定s和p都从空字符开始
        
        for i in range(len(s)):  # s的空字符需要额外初始化
            for j in range(1, len(p)+1):
                if p[j-1] == '*':   # *可以出现0次或者多次
                    dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (s[i]==p[j-2] or p[j-2]=='.'))

                else: # '.'和普通字母的情况可合为一种
                    dp[i][j] = dp[i-1][j-1] and (s[i]==p[j-1] or p[j-1]=='.')

        return dp[-1][-1]