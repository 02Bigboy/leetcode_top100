1. 两数之和=target：代码学到的就是用enumerate遍历数组，返回的是index，value的格式，以及用字典存储值和序号
2. 两个链表之和：代码学到单链表的定义--存储位置，value，next的位置，链表一般以头结点作为链表--即头结点的地址
3. 无重复最长子串：和1一样，字典存储，然后查找更新
4. 两个正序数组的中位数：转化为找第中间小的元素。代码学到了如何求有序数列的第几小
5. 最长回文子串：感觉可以继续优化，代码学到了数组倒序[::-1]
10. 感觉需要再记一下，没太明白
11. 盛最多水的容器：从两边分别往中间取(较小的往中间走)，算面积，保留最大面积
15. 三数之和：转变为两数之和，代码学到了.sort()对列表进行就地排序，不返回任何值里面可以加reverse=bool，
    来选择是否进行降序排列（默认是升序排列），与它相似的是y = sorted(x)的形式，会返回一个排序列表，不改变原有序列
17. 电话号码字母组合：学到了回溯法，深度优先，里面的变量其实都是全局的，要想return后相应的变量也是之前的状态
    则需要用好新变量(即中间变量，就像这里的index+1，以及a的使用)
    深度优先的回溯法，其实可以理解为有很多循环，循环的最后一层就是最终的return，只要最后一层都return完了，则回溯就完了
19. 删除链表的第N个节点：学到了链表里面的快慢指针，以及链表共用头结点，表示同一个链表
20. 有效的括号：学到了replace函数
21. 合并两个有序链表：学到了链表的传入，出来next要赋值，还要将当前的链表指到下一个去
22. 括号的生成：由复杂到简单的思想，也可以用回溯法解
23. 技术有点多，等周末仔细的学一下
31. 下一个排序：降序组成的数，就是最大值，没有比他更小的值
32. 最长连续有效括号：思想：复杂的简单化--先找能组成对的括号，保留他们的index，然后对index排序，找出最长连续数列就可以了
33. 搜索旋转排列数组：有序数列，二分法查找值
34. 排列数组中查找元素起始位置：根据算法复杂度，二分法查找
39. 数组总和：学到了回溯如何减枝，这里为了避免重复，则每一层的节点，不取右边的数
42. 接雨水：转化为每根柱子能接的水，然后把所有柱子的接水加起来就可以了
46. 全排列：学到了如果不使用中间变量的话，直接进行变量传递，则回溯每次返回的时候，需要把变量回退到最开始的样子
48. 顺时针旋转90度，等价于先水平翻转，在对角线翻转
49. 字母异味词：学到了用collections，定义字典里值得类型，然后异味词排序后都是一样的，所以可以根据这个来添加异味词
53. 最大连续子数组和：动态规划，以每个点最为结束值的连续子数列的最大和，当前的是根据前面一个判断的，前面小于0，则就是当前数
    前面大于等于0，则就是前面的加上当前数
55. 跳跃游戏：保存前面能够跳到的最大值，前面能跳到的最大值至少要到当前位置，然后看看当前位置跳的地方来决定更新最大位置
56. 合并区间：先根据区间的起始值进行排序就好做了
62. 不同路径：用动态规划解，这其实是比较简单的动态规划，ctc那种解码感觉比较复杂一点，但基础是这个
64. 最小路径和：动态规划：学到了二维的动态规划初始化，应该一行一列
70. 爬楼梯：一维的动态规划，初始化有两个值---初始化的值应该看动态方程，动态方程需要多少，就需要多少初始化的值
72. 编辑距离：动态规划，word1的前1个到word2前j个的最小操作，然后动态递进
75. 颜色分类：因为这只有三类，所以可以用技巧性比较强的交换来做，如果更多类的话，可以考虑冒泡那些
76. 覆盖最小子串：有点复杂，状态好，再来看一下
78. 子集：回溯法，将每种子集都算上，学到了，回溯法可以没有返回值，其实就是看最后变量就行了
79. 单词搜索：由繁到简，先找到一个，然后找下一个，代码学到了函数定义，要在函数使用之前
84. 最大柱形面积：有点复杂，到时候再想
85. 承接着84
94. 二叉树中序遍历：前，中，后序，都是针对什么时候取root.val命名的。
96. 二叉搜索树：左子树小于根节点的值，右子树大于根节点的值
98. 验证二叉搜索树：根据二叉树特点一个个节点验证
101. 对称二叉树，用递归
102. 二叉树层序遍历：学到了，先进先出如何pop
105. 从前序和中序遍历结果构造二叉树
114. 后面再看
124. 二叉树的最大路径：就是找出以当前节点为起点的最大路径，然后max
128. 最长序列：学到了以set，来存储列表方便查找--时间复杂度很低
136. 只出现一次的数字：学到了异或^,以及reduce函数
139. 单词拆分：先找到第一个单词再说，再找后面
141. 环形链表：用一个字典存储，然后后面的就查看在不在字典里面
142. 就是141的小改动，即返回环 的头
146. LRU缓存，有点复杂后面再看
148. 排序链表：中间分，再排序，再结合，学到了如何断开链表：在想断开的地方id.next = None 即断开
153. 乘积最大子数组--乘积的连续最大，保留最大和最小
155. 最小栈---同时存储最顶端值和最小值
160. 相交链表---遍历
169. 多数元素---字典保存
198. 打家劫舍--简单的变量动态规划
206. 反转链表，这个有点思想有点复杂，记一下吧
# TODO
    10
链表：
    2.单链表的定义，以及链表（一串单链表连接起来）
    19.链表的头，就可以确定一个链表
    21.链表的增加元素--两步new.next = ListNode(list2.val) new = new.next
    141.环形链表判断--字典存储
    142.跟141其实是一样的
    148.排序链表
    206.反转链表
回溯法：
    17.回溯法的变量使用，以及什么是回溯法--一颗树，以及深度优先
    22.回溯法，以及return的条件可以有多个，以为其实我们只想要变量的值，
        多个return的条件可以看成减枝，并入本题，左括号数不能大于n，以及已经形成的字符，
        右括号肯定不能比左括号多
    39.深度优先dfs的回溯法
    46.全排列，深度优先，但不能取那条路已经取过的值
    78.回溯法库没有返回值
    79.分步骤的回溯
    94.二叉树中序遍历
二分法：
    33. 二分法查找值，不断的二分，那个值在mid处
    34. 不断二分，找出>=target 的闭区间最左端值
动态规划：
    53. dp[i] = max(dp[i-1], 0) + nums[i]
    62. 动态方程，初始化
    64. 动态规划，初始化行列，单独进行
    70. 动态规划，两个初始化条件，比较简单
    72. 三个方向可以走，很有意思
    139. 前面i是否能在dict里找到
    198. 打家劫舍
二叉树
    94.二叉树中序遍历，结合回溯一起做，了解了什么叫前中后序遍历
    96.二叉搜索树
    98.验证搜索二叉树的方法
    101. 对称二叉树
    102.二叉树层序遍历
    105.前序中序构造二叉树
    124.二叉树最大路径
注册， 注册邀请函，需要护照号码。注册时要不要填护照号